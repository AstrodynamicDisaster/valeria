#!/usr/bin/env python3
"""
ValerIA Database Reset Script
Drops all tables and recreates a clean database for testing

WARNING: This will delete ALL data in the database!

Usage:
    python scripts/reset_database.py              # Normal mode (with confirmation)
    python scripts/reset_database.py --force      # Force mode (terminates connections)
    python scripts/reset_database.py --docs       # Also reset documents folder
    python scripts/reset_database.py --test-data  # Also reset test data folder
"""

import os
import sys
import argparse
import shutil
from sqlalchemy import create_engine, text, MetaData
from sqlalchemy.exc import OperationalError

# Add parent directory to path to import core module
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.models import Base
from core.database import create_database_engine


def confirm_reset(force: bool = False):
    """Ask user to confirm database reset"""
    print("‚ö†Ô∏è  WARNING: This will DELETE ALL data in the ValerIA database!")
    print("   This action cannot be undone.")
    print()

    if force:
        response = input("Type 'FORCE' to confirm: ")
        return response.strip() == 'FORCE'
    else:
        response = input("Are you sure you want to reset the database? (type 'YES' to confirm): ")
        return response.strip() == 'YES'


def reset_database_normal():
    """Drop all tables using SQLAlchemy metadata"""
    print("üîÑ Starting database reset (normal mode)...")

    try:
        # Create database engine
        engine = create_database_engine()
        print("‚úì Database connection established")

        # Drop all tables using SQLAlchemy metadata
        print("üóëÔ∏è  Dropping all existing tables...")

        # Reflect current database structure
        metadata = MetaData()
        metadata.reflect(bind=engine)

        # Drop all tables in reverse dependency order
        metadata.drop_all(engine)
        print("‚úì All tables dropped successfully")

        # Drop any remaining sequences (auto-generated by SERIAL columns)
        with engine.connect() as conn:
            result = conn.execute(text("""
                SELECT sequence_name FROM information_schema.sequences
                WHERE sequence_schema = 'public';
            """))

            sequences = result.fetchall()
            for (seq_name,) in sequences:
                try:
                    conn.execute(text(f"DROP SEQUENCE IF EXISTS {seq_name} CASCADE;"))
                    print(f"  ‚úì Dropped sequence: {seq_name}")
                except Exception as e:
                    print(f"  ‚ö†Ô∏è  Could not drop sequence {seq_name}: {e}")

            # Commit the changes
            conn.commit()

        print("‚úì Database reset completed successfully!")
        return True

    except OperationalError as e:
        if "does not exist" in str(e).lower():
            print("‚ùå Database connection failed. Make sure PostgreSQL is running.")
        else:
            print(f"‚ùå Database error: {e}")
        return False

    except Exception as e:
        print(f"‚ùå Unexpected error during reset: {e}")
        return False


def reset_database_force():
    """Force reset database by terminating connections and dropping tables"""
    print("üîÑ Force resetting database...")

    try:
        # Get database connection details from environment
        db_host = os.getenv('POSTGRES_HOST', 'localhost')
        db_port = os.getenv('POSTGRES_PORT', '5432')
        db_user = os.getenv('POSTGRES_USER', 'valeria')
        db_password = os.getenv('POSTGRES_PASSWORD', 'YourStrongPassw0rd!')
        db_name = os.getenv('POSTGRES_DB', 'valeria')

        db_url = f"postgresql://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}"

        # Create engine with autocommit for administrative commands
        engine = create_engine(db_url, isolation_level="AUTOCOMMIT")
        print("‚úì Database connection established")

        with engine.connect() as conn:
            # First, terminate all other connections to the database
            print("üîå Terminating active connections...")
            try:
                conn.execute(text(f"""
                    SELECT pg_terminate_backend(pg_stat_activity.pid)
                    FROM pg_stat_activity
                    WHERE pg_stat_activity.datname = '{db_name}'
                    AND pid <> pg_backend_pid();
                """))
                print("‚úì Active connections terminated")
            except Exception as e:
                print(f"‚ö†Ô∏è  Could not terminate connections: {e}")

            # Drop tables in dependency order (manually specified)
            tables_to_drop = [
                'payroll_lines',
                'documents',
                'checklist_items',
                'payrolls',
                'vacation_periods',  # Must be dropped before employees
                'employees',
                'clients',
                'nomina_concepts'
            ]

            print("üóëÔ∏è  Dropping tables...")
            for table in tables_to_drop:
                try:
                    conn.execute(text(f"DROP TABLE IF EXISTS {table} CASCADE;"))
                    print(f"  ‚úì Dropped table: {table}")
                except Exception as e:
                    print(f"  ‚ö†Ô∏è  Could not drop table {table}: {e}")

            # Drop any remaining sequences
            print("üóëÔ∏è  Dropping sequences...")
            try:
                result = conn.execute(text("""
                    SELECT sequence_name FROM information_schema.sequences
                    WHERE sequence_schema = 'public';
                """))

                sequences = result.fetchall()
                for (seq_name,) in sequences:
                    try:
                        conn.execute(text(f"DROP SEQUENCE IF EXISTS {seq_name} CASCADE;"))
                        print(f"  ‚úì Dropped sequence: {seq_name}")
                    except Exception as e:
                        print(f"  ‚ö†Ô∏è  Could not drop sequence {seq_name}: {e}")
            except Exception as e:
                print(f"‚ö†Ô∏è  Could not query sequences: {e}")

        print("‚úÖ Force reset completed successfully!")
        return True

    except Exception as e:
        print(f"‚ùå Force reset failed: {e}")
        import traceback
        traceback.print_exc()
        return False


def reset_documents_folder():
    """Reset the local documents folder"""
    print("üóëÔ∏è  Resetting documents folder...")

    docs_dir = "./documents"

    if os.path.exists(docs_dir):
        try:
            shutil.rmtree(docs_dir)
            print("‚úì Documents folder removed")
        except Exception as e:
            print(f"‚ö†Ô∏è  Could not remove documents folder: {e}")

    # Recreate empty documents folder
    os.makedirs(docs_dir, exist_ok=True)
    print("‚úì Clean documents folder created")


def reset_test_data_folder():
    """Reset test data folder"""
    print("üóëÔ∏è  Resetting test data...")

    test_data_dir = "./test_data"

    if os.path.exists(test_data_dir):
        try:
            shutil.rmtree(test_data_dir)
            print("‚úì Test data folder removed")
        except Exception as e:
            print(f"‚ö†Ô∏è  Could not remove test data folder: {e}")


def main():
    """Main reset function"""
    parser = argparse.ArgumentParser(
        description='ValerIA Database Reset Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python scripts/reset_database.py                    # Normal reset with confirmation
  python scripts/reset_database.py --force            # Force reset (terminates connections)
  python scripts/reset_database.py --docs             # Reset database and documents folder
  python scripts/reset_database.py --force --docs --test-data  # Complete reset
        """
    )

    parser.add_argument(
        '--force',
        action='store_true',
        help='Force reset by terminating active connections (more aggressive)'
    )

    parser.add_argument(
        '--docs',
        action='store_true',
        help='Also reset the documents folder'
    )

    parser.add_argument(
        '--test-data',
        action='store_true',
        help='Also reset the test data folder'
    )

    args = parser.parse_args()

    print("üöÄ ValerIA Database Reset Tool")
    print("=" * 50)

    # Confirm reset
    if not confirm_reset(force=args.force):
        print("‚ùå Database reset cancelled.")
        return 1

    # Reset database tables
    if args.force:
        success = reset_database_force()
    else:
        success = reset_database_normal()

    if not success:
        return 1

    # Reset local file storage if requested
    if args.docs:
        reset_documents_folder()

    # Reset test data if requested
    if args.test_data:
        reset_test_data_folder()

    print()
    print("üéâ Reset completed successfully!")
    print()
    print("Next steps:")
    print("1. python scripts/setup_database.py")
    print("2. python scripts/generate_test_data.py")

    return 0


if __name__ == "__main__":
    exit(main())
